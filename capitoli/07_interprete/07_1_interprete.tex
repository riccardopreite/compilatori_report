\documentclass[../../main]{subfiles}
\begin{document}

\subsection{Interprete SimplanPlus}
L'interprete di \textbf{SimpLanPlus} prende in input il codice precedentemente generato dal compilatore e lo esegue un'istruzione alla volta. 
\subsubsection{Bytecode}
Per ogni nodo dell'AST è presente un metodo \emph{String codeGeneration()} che genera il bytecode rispettando la grammatica presente nel file \emph{SVG.g4}.
Ogni istruzione è composta da: 
\begin{itemize}
    \item \textbf{Label istruzione}: è una stringa obbligatoria che identifica un'istruzone. 
    \item \textbf{Primo argomento}: serve per specificare un registro o un'etichetta. È una stringa opzionale perché non tutte le istruzioni prevedono questo argomento (es. POP).
    \item \textbf{Secondo argomento}: serve per specificare un registro o un numero. È una stringa opzionale.
    \item \textbf{Terzo argomento}: serve per specificare un registro, un numero o un'etichetta. È una stringa opzionale.
\end{itemize}
Per ogni istruzione letta viene creato un oggetto di tipo \emph{Instruction}, definito dalla classe Instruction.java.
\subsubsection{CPU e memoria}
L'interprete simula il comportamento di una CPU e di una memoria.
La CPU ha 9 registri: 
\begin{itemize}
    \item \textbf{Stack pointer (\$sp)}: punta alla cima dello stack
    \item \textbf{Instruction pointer (\$ip)}: indica la prossima istruzione da eseguire
    \item \textbf{Heap pointer (\$hp)}: punta alla prima posizione libera dello \emph{heap}
    \item \textbf{Frame pointer (\$fp)}: punta all'access link corrente relativo al frame attivo
    \item \textbf{Access link (\$al)}: registro utilizzato per attraversare la catena statica degli scope
    \item \textbf{Base stack pointer (\$bsp)}: punta alla cella di memoria contenente il vecchio stack pointer, utile nel caso si esca da una funzione prima della fine delle istruzioni tramite un return
    \item \textbf{Accumulatore (\$a0)}: registro utilizzato per salvare il valore calcolato da alcune espressioni
    \item \textbf{Registro generico (\$t1)}: utilizzabile liberamente all'interno del programma  
    \item \textbf{Return address (\$ra)}: registro utilizzato per salvare l'indirizzo di ritorno una volta usciti da un frame
\end{itemize}
La CPU esegue le istruzioni passate al costruttore dall'interprete. Dopodiché, ad ofni iterazione, si accede all'istruzione indicata dal registro \emph{\$ip} che poi viene incrementato di uno per passare ad eseguire l'istruzione successiva. L'operazione da eseguire dipende dal campo \emph{code} dell'oggetto \emph{Instruction}.  
\newline
Per gestire i registri si utilizzano le funzioni \emph{regStore} e \emph{regRead} per aggiornare e leggere il valore contenuto nel registro opportuno.
\newline

Per quanto riguarda la \emph{memoria}, questa viene gestita come un array di \emph{Cell}. La memoria è divisa logicamente nello stack (che cresce verso il basso e quindi indici della memoria minori) e lo heap (che parte da indice 0 e cresce verso l'alto e quindi verso indici maggiori).
\newline
La classe \emph{Cell} rappresenta una singola cella di memoria. I campi presenti in questa classe sono:
\begin{itemize}
    \item \emph{Integer val}: rappresenta il valore salvato nella cella di memoria
    \item \emph{boolean pointed}: indica se la cella della memoria è puntata oppure è vuota e quindi può essere scritta
\end{itemize}
Sono stati implementati i seguenti metodi per facilitare la gestione delle celle di memoria: 
\begin{itemize}
    \item \emph{void free()}: libera una cella di memoria
    \item \emph{Integer read()}: ritorna il dato contenuto nella cella di memoria
    \item \emph{boolean isPointed()}: ritorna un true o false se la cella è in uso oppure no
    \item \emph{void allocate()}: setta a true il campo \emph{isPointed} e quindi segna come in uso la cella di memoria
    \item \emph{Integer write(int v)}: aggiorna la cella con \emph{v}
\end{itemize}
\newline
Nella classe \emph{Memory} sono presenti i seguenti metodi per la gestione della memoria: 
\begin{itemize}
    \item \emph{int read(int n)} che ritorna il contenuto della memoria nella cella \emph{n}
    \item \emph{void write(int add, int val)} che scrive il valore \emph{val} all'indirizzo \emph{add}
    \item \emph{void free(int add)} che chiama la \emph{free} su quella cella, mettendo il campo \emph{pointed} a false e il campo \emph{val} a null
    \item \emph{void cleanMemory(int start, int end)} che re-inizializza tutte le celle comprese tra start ed end
\end{itemize}

\end{document}